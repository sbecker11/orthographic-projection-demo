<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XForm Tester</title>
    <script>
        // Inline script to set theme class ASAP to prevent flicker
        (function() {
            const themeKey = 'transformTesterTheme';
            const savedTheme = localStorage.getItem(themeKey);
            if (savedTheme === 'dark') {
                document.documentElement.classList.add('dark-theme');
            }
        })();
    </script>
    <style>
        body {
            margin: 20px;
            font-family: Arial, sans-serif;
            background-color: var(--bg-color-primary);
            color: var(--text-color-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh; /* Ensure body takes full height */
        }
        .three-column-layout {
            display: flex;
            gap: 20px;
            width: 100%;
            max-width: 1100px; /* Reduced max-width */
            align-items: flex-start; /* Align items to the top */
            position: relative; /* Needed for viewport-actions positioning */
        }
        .left-column, .right-column {
            flex: 1; /* Allow left and right columns to grow */
            min-width: 220px; /* Reduced min-width */
            padding: 20px;
            background-color: var(--bg-color-secondary);
            border-radius: 8px;
            box-shadow: var(--shadow-elevation-low);
            height: fit-content; /* Adjust height based on content */
            border: none; /* Remove previous border, use fieldset */
            display: flex; /* Use flexbox for children */
            flex-direction: column; /* Stack fieldsets vertically */
            gap: 15px; /* Space between fieldsets */
        }
        .center-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            position: relative; /* Positioning context for theme toggle */
            padding-top: 44px; /* toggle height (24) + desired gap (20) */
        }
        #viewport {
            position: relative; /* Needed for absolute positioning of rects */
            background-color: white; /* Keep background */
            border-radius: 8px;
            /* Bevel effect */
            border: 1px solid #aaa;
            box-shadow: inset 3px 3px 6px rgba(0,0,0,0.2),
                        inset -2px -2px 5px rgba(255,255,255,0.6),
                        0 4px 8px rgba(0,0,0,0.15); /* Optional outer shadow */
            overflow: hidden;
            width: 400px; /* Reduced width */
            height: 400px; /* Reduced height */
            perspective: 1000px; /* Enable 3D space for children */
        }
        .rect {
            position: absolute;
            width: 100px;
            height: 60px;
            border-radius: 4px;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px black;
            box-sizing: border-box; /* Include padding/border in element's total width and height */
            transform-style: preserve-3d; /* Important for containing 3D transforms */
            transition: transform 0.5s ease-in-out; /* Default transition */
        }
        .rect-start {
            background-color: rgba(0, 128, 0, 0.8); /* Green, semi-transparent */
            border: 2px solid darkgreen;
            z-index: 1; /* Start rect below */
            cursor: grab; /* Make it grabbable */
            position: absolute; /* Keep absolute positioning */
        }
        .rect-end {
            background-color: rgba(255, 0, 0, 0.8); /* Red, semi-transparent */
            border: 2px solid darkred;
            z-index: 2; /* End rect above, draggable */
            position: absolute; /* Keep absolute positioning */
        }
        .rect-end:active {
            cursor: grabbing;
        }
        .controls-column h2,
        .persistence-column h2 {
            margin-top: 0;
            margin-bottom: 10px; /* Space below H2 inside fieldset */
            font-size: 1.1em; /* Slightly smaller H2 */
        }
        fieldset {
            /* border: 1px solid var(--border-color-strong); Remove border */
            border: none;
            border-radius: 6px;
            padding: 15px;
            margin: 0; /* Reset default fieldset margin */
            width: 100%; /* Take full width of parent column */
            box-sizing: border-box;
        }
        /* legend {
            padding: 0 5px;
            font-weight: bold;
            color: var(--text-color-primary);
            margin-left: 10px; 
            font-size: 1em;
        } */

        /* Style the new labels as section headers */
        .control-section > label {
            display: block; /* Make label take full width */
            font-weight: bold;
            margin-bottom: 10px; /* Space below label */
            font-size: 1.1em;
            color: var(--text-color-primary);
        }

        .control-section {
            /* padding: 2px 0; Further reduce vertical padding */
            padding: 0; /* Remove padding, rely on gap */
        }

        .control-group {
             margin-bottom: 5px; /* Further reduce space */
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="number"], input[type="text"] {
            width: calc(100% - 16px);
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button.secondary {
            background-color: #6c757d;
        }
        button.secondary:hover {
            background-color: #5a6268;
        }
         button.danger {
            background-color: #dc3545;
        }
        button.danger:hover {
            background-color: #c82333;
        }
        #savedList { /* Target the ul directly */
            list-style: none;
            padding: 0;
            max-height: 300px; /* Keep max-height */
            overflow-y: auto;
        }
         #savedList li { /* Target li directly */
            padding: 10px;
            border: 1px solid #eee;
            margin-bottom: 5px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        .saved-transitions li:hover {
            background-color: #f8f9fa;
        }
        .saved-transitions li.selected {
            background-color: #e0e0e0;
            font-weight: bold;
        }
        .transition-name {
             flex-grow: 1;
             margin-right: 10px;
             overflow: hidden;
             text-overflow: ellipsis;
             white-space: nowrap;
        }
        .direction-toggle span:first-child { /* Target the label span specifically */
            display: inline-block;
            width: 30px; /* Fixed width for alignment */
            color: var(--text-color-primary);
        }
        .rot-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            margin-left: 0px; /* Remove left margin */
            margin-right: 8px;
            vertical-align: middle;
            background-size: contain; /* Or 16px 16px */
            background-repeat: no-repeat;
            background-position: center;
        }
        .rot-icon[data-axis="x"] { background-image: url('icons/x-rot.png'); }
        .rot-icon[data-axis="y"] { background-image: url('icons/y-rot.png'); }
        .rot-icon[data-axis="z"] { background-image: url('icons/z-rot.png'); }
        .dark-theme .rot-icon[data-axis="x"] { background-image: url('icons/x-rot-dark.png'); }
        .dark-theme .rot-icon[data-axis="y"] { background-image: url('icons/y-rot-dark.png'); }
        .dark-theme .rot-icon[data-axis="z"] { background-image: url('icons/z-rot-dark.png'); }
        .direction-toggle button {
            padding: 5px 0; /* Adjust padding for consistent height */
            font-size: 0.9em; /* Slightly smaller text */
            width: 30px; /* Fixed width for all */
            min-width: auto; /* Allow button to be smaller */
            margin-left: 5px;
            margin-bottom: 5px; /* Add bottom margin */
            text-align: center;
            line-height: 1.2; /* Adjust for vertical centering */
        }
        .direction-toggle button.active {
            background-color: #28a745; /* Green for active */
            border: 1px solid #1e7e34;
            opacity: 1.0;
        }
        .direction-toggle button:not(.active) {
            background-color: #6c757d; /* Grey for inactive */
            opacity: 0.7;
        }
        /* Specific style for active zero button */
        .direction-toggle button[data-value="0"].active {
             background-color: #ffc107; /* Yellow for zero */
             color: #333;
             border-color: #e0a800;
             opacity: 1.0;
        }
        .point-marker {
            position: absolute;
            width: 15px;
            height: 15px;
            background-color: rgba(0, 0, 255, 0.7);
            border: 1px solid darkblue;
            border-radius: 50%;
            cursor: pointer;
            transform: translate(-50%, -50%); /* Center the marker on the click point */
            z-index: 3; /* Above rects */
        }
        .point-marker.selected {
            background-color: rgba(0, 255, 255, 0.9); /* Cyan when selected */
            border: 2px solid teal;
        }

        /* Header */
        .app-header {
            width: 100%;
            display: flex;
            /* justify-content: space-between; Let button be positioned independently */
            align-items: center;
            padding: 10px 20px;
            box-sizing: border-box;
            /* margin-bottom: 15px; Reduce space below header */
            margin-bottom: 5px;
        }
        .app-header h1 {
            margin: 0;
            flex-grow: 1;
            margin-bottom: 10px; /* Add some space below title */
        }

        #themeToggle {
            position: absolute;
            top: 0px;  /* Position at the top of the center column's padding */
            right: 0;    /* Align with right edge of viewport container */
            z-index: 10; /* Ensure it's clickable */
            width: 60px;
            height: 24px;
            border-radius: 12px; /* height / 2 */
            border: 1px solid var(--border-color-strong);
            background-color: var(--bg-color-toggle-off);
            cursor: pointer;
            transition: background-color 0.3s ease;
            box-sizing: border-box;
            appearance: none; /* Remove default button styles */
            /* Clear content for pseudo-element */
            color: transparent;
            font-size: 0;
            line-height: 0;
        }

        #themeToggle::before {
            content: '';
            position: absolute;
            width: 20px; /* Size of the switch circle */
            height: 20px;
            border-radius: 50%;
            background-color: var(--bg-color-toggle-switch);
            top: 1px; /* Center vertically */
            left: 1px;
            transition: transform 0.3s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .dark-theme #themeToggle {
            background-color: var(--bg-color-toggle-on);
        }

        .dark-theme #themeToggle::before {
            transform: translateX(36px); /* Adjust based on size/padding */
        }

        /* Layout */
        .three-column-layout {
            display: flex;
            gap: 20px;
            width: 100%;
            max-width: 1100px; /* Reduced max-width */
            align-items: flex-start; /* Align items to the top */
            position: relative; /* Needed for viewport-actions positioning */
        }

        /* Block size controls row */
        .block-size-controls {
            display: flex;
            align-items: center;
            gap: 5px; /* Reduced gap */
            /* Calculate total width similar to duration */
            /* Label width can be flexible */
        }
        .block-size-controls label {
             margin-bottom: 0; /* Remove bottom margin for inline label */
             white-space: nowrap;
             flex-shrink: 0; /* Prevent label from shrinking */
             margin-right: auto; /* Push inputs/button to the right */
             line-height: 28px; /* Align label vertically */
        }
        .block-size-controls input[type="number"] {
             width: 57px; /* Increased width */
             margin-bottom: 0;
             height: 100%; /* Match parent height */
             box-sizing: border-box;
             margin-right: 5px; /* Add right margin */
        }
        .block-size-controls span { /* The 'x' */
            margin: 0 2px;
        }
        .block-size-controls button {
            margin-bottom: 0;
            flex-shrink: 0; /* Prevent button from shrinking */
            padding: 10px 8px; /* Increase top/bottom padding */
            min-width: auto; /* Allow button to be smaller */
            height: 100%; /* Match parent height */
            box-sizing: border-box;
        }

        /* Viewport Actions (Start/Replay/Reset) */
        .viewport-actions {
            display: flex;
            justify-content: center;
            gap: 10px;
            width: 100%; /* Span width below viewport */
            margin-top: 10px; /* Space above buttons */
        }

        .right-column {
            /* margin-top: -40px; Remove this adjustment for now */
        }

        .direction-toggle {
            display: flex; /* Use flexbox to keep elements in a row */
            align-items: center; /* Vertically align label, icon, buttons */
            margin-bottom: 8px; /* Space between rows */
        }

        #duration { /* Specific style for duration input */
            width: 147px; /* Adjusted for approx 20px spinner width */
            margin-left: auto; /* Push input to the right if label is short */
        }

        /* Waypoint controls row */
        .waypoint-controls {
            display: flex;
            align-items: center;
            /* padding: 0 5px; Remove padding */
            /* gap: 10px; Add gap between elements */
            gap: 6px; /* Reduce gap */
        }
        .waypoint-controls > button:first-child {
            margin-right: 0; /* Override auto margin */
        }

        .waypoint-btn { /* Class for Add/Del buttons */
            min-width: 50px; /* Ensure enough space for Add+ */
            text-align: center;
        }

        #waypointCounter {
            font-weight: bold;
            color: var(--text-color-secondary);
            /* min-width: 25px; Tighter width for 2 digits */
            min-width: 40px; /* Adjusted width */
            text-align: center;
        }

        #deleteLastWaypointButton[disabled] { /* Simpler selector test */
            background-color: #cccccc !important; /* Light grey background - Force */
            color: #888888 !important; /* Dimmer text - Force */
            cursor: not-allowed !important; /* Force cursor */
        }

        /* Optional: Explicitly prevent hover style changes */
        #deleteLastWaypointButton[disabled]:hover { /* Simpler selector test */
            background-color: #cccccc !important; /* Keep it grey - Force */
            /* color: #888888; Keep text dim */
        }

        :root {
            --bg-color-primary: #f0f0f0;
            --bg-color-secondary: #ffffff;
            --text-color-primary: #333333;
            --text-color-secondary: #666666;
            --border-color: #dddddd;
            --border-color-strong: #aaaaaa;
            --button-bg: #007bff;
            --button-hover-bg: #0056b3;
            --button-danger-bg: #dc3545;
            --button-danger-hover-bg: #c82333;
            --shadow-elevation-low: 0 1px 2px rgba(0,0,0,0.05);
            --shadow-elevation-medium: 0 4px 8px rgba(0,0,0,0.1);
            --text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            /* Theme Toggle Colors (Light) */
            --bg-color-toggle-off: #cccccc; /* Grey when off (light theme) */
            --bg-color-toggle-on: #007bff; /* Blue when on (light theme) */
            --bg-color-toggle-switch: #ffffff; /* White switch */
        }

        .dark-theme {
            --bg-color-primary: #22272e;
            --bg-color-secondary: #2d333b;
            --text-color-primary: #cdd9e5;
            --text-color-secondary: #97a6b7;
            --border-color: #444c56;
            --border-color-strong: #586069;
            --button-bg: #3081f7;
            --button-hover-bg: #458ff7;
            --button-danger-bg: #f85149;
            --button-danger-hover-bg: #fa675f;
            --shadow-elevation-low: 0 1px 2px rgba(0,0,0,0.2);
            --shadow-elevation-medium: 0 4px 8px rgba(0,0,0,0.3);
            --text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            /* Theme Toggle Colors (Dark) */
            --bg-color-toggle-off: #586069; /* Dark grey when off (dark theme) */
            --bg-color-toggle-on: #3081f7;  /* Blue when on (dark theme) */
            --bg-color-toggle-switch: #22272e; /* Dark switch */
        }

        /* Utility Classes */
        .no-select {
            user-select: none; /* Standard */
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* IE/Edge */
        }
    </style>
</head>
<body>

    <div class="app-header">
        <h1>XForm Tester</h1>
    </div>

    <div class="three-column-layout">
        <!-- Left: Persistence -->
        <div class="left-column persistence-column">
            <fieldset>
                <legend>Saved Transitions</legend>
                <ul id="savedList">
                    <!-- Saved transitions will be listed here -->
                    <li>No transitions saved yet.</li>
                </ul>
                <div class="control-group" id="selectedTransitionControls" style="display: none;">
                    <input type="text" id="renameInput" placeholder="New name">
                    <button id="renameTransition" class="secondary">Rename</button>
                    <button id="deleteTransition" class="danger">Delete</button>
                    <button id="replayTransition">Replay Selected</button>
                </div>
                <div class="control-group" style="margin-top: 15px; text-align: center;">
                    <button id="saveTransition">Save Current Configuration</button>
                </div>
            </fieldset>
        </div>

        <!-- Center: Viewport & Actions -->
        <div class="center-column">
            <button id="themeToggle" title="Toggle Theme"></button>
            <div id="viewport">
                <!-- Rectangles will be added here by JS -->
            </div>
            <div class="viewport-actions">
                <button id="startTransition">Start</button>
                <button id="replayTransitionBtn">Replay</button>
                <button id="resetPositions">Reset</button>
            </div>
        </div>

        <!-- Right: Controls -->
        <div class="right-column controls-column">
            <div class="control-section">
                <label for="rotations">Rotations:</label>
                <div class="control-group" style="margin-bottom: 5px;">
                    <div class="direction-toggle" data-axis="x" data-direction="1">
                        <span>X:</span><span class="rot-icon" data-axis="x"></span>
                        <button class="btn-dir active" data-value="1">+</button>
                        <button class="btn-dir" data-value="0">0</button>
                        <button class="btn-dir" data-value="-1">-</button>
                    </div>
                    <div class="direction-toggle" data-axis="y" data-direction="1">
                        <span>Y:</span><span class="rot-icon" data-axis="y"></span>
                        <button class="btn-dir active" data-value="1">+</button>
                        <button class="btn-dir" data-value="0">0</button>
                        <button class="btn-dir" data-value="-1">-</button>
                    </div>
                    <div class="direction-toggle" data-axis="z" data-direction="1">
                        <span>Z:</span><span class="rot-icon" data-axis="z"></span>
                        <button class="btn-dir active" data-value="1">+</button>
                        <button class="btn-dir" data-value="0">0</button>
                        <button class="btn-dir" data-value="-1">-</button>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <label for="duration">Duration (ms):</label>
                <div class="control-group">
                    <input type="number" id="duration" value="500" min="0" step="50">
                </div>
            </div>

            <div class="control-section">
                <label for="rectangle">Rectangle:</label>
                <div class="control-group block-size-controls">
                    <input type="number" id="rectWidth" value="100" min="50" max="400" title="Width (50-400px)">
                    <input type="number" id="rectHeight" value="60" min="50" max="400" title="Height (50-400px)">
                </div>
            </div>

            <div class="control-section">
                <label for="waypoints">Waypoints:</label>
                <div class="control-group waypoint-controls">
                    <button id="addWaypointBtn" class="waypoint-btn">Add +</button>
                    <span id="waypointCounter">0</span>
                    <button id="deleteLastWaypointBtn" class="danger waypoint-btn" disabled>- Del</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM Loaded. Initializing XForm Tester...');

            // --- DOM Elements (Declare ONCE) ---
            const viewport = document.getElementById('viewport');
            const addWaypointButton = document.getElementById('addWaypointBtn');
            const waypointCounter = document.getElementById('waypointCounter');
            const deleteLastWaypointButton = document.getElementById('deleteLastWaypointBtn');
            console.log("Initial check - deleteLastWaypointButton element:", deleteLastWaypointButton); // Check if element exists
            const widthInput = document.getElementById('rectWidth');
            const heightInput = document.getElementById('rectHeight');
            const applySizeButton = document.getElementById('applySize');
            const durationInput = document.getElementById('duration');
            const startButton = document.getElementById('startTransition');
            const replayButton = document.getElementById('replayTransitionBtn');
            const resetButton = document.getElementById('resetPositions');
            const savedListUl = document.getElementById('savedList');
            const selectedControlsDiv = document.getElementById('selectedTransitionControls');
            const renameInput = document.getElementById('renameInput');
            const renameButton = document.getElementById('renameTransition');
            const deleteButton = document.getElementById('deleteTransition');
            const replaySavedButton = document.getElementById('replayTransition'); // In selected controls
            const currentNameDisplay = document.getElementById('currentTransitionNameDisplay');
            const editCurrentNameButton = document.getElementById('editCurrentNameBtn');
            const editCurrentNameInput = document.getElementById('editCurrentNameInput');
            const saveCurrentNameButton = document.getElementById('saveCurrentNameBtn');
            const saveButton = document.getElementById('saveTransition'); // Main save button
            const themeToggleButton = document.getElementById('themeToggle');
            console.log("Initial check - themeToggleButton element:", themeToggleButton); // Check element selection

            // NOTE: startRect and endRect are created dynamically, so use 'let'
            let startRect = null;
            let endRect = null;

            // --- State Variables ---
            let xRotationDirection = 1;
            let yRotationDirection = 1;
            let zRotationDirection = 1;
            let isAddingPoints = true; // Always in WAM mode
            let intermediatePoints = []; // Array to store {x, y, element} of intermediate points
            let selectedPointIndex = -1; // Index of the selected intermediate point
            let draggingPointIndex = -1; // Index of the point being dragged
            let lastModifiedPointIndex = -1; // Track most recently modified point
            let dragOffsetX = 0;
            let dragOffsetY = 0;
            let selectedSavedTransitionId = null;
            let wasDraggingPoint = false; // Flag to prevent click after drag

            // --- Current Transition State ---
            let currentTransitionName = "New Transition";
            let currentTransitionId = null; // Can be null (new) or a timestamp (run/loaded/saved)
            let currentTransitionHasRun = false;

            // --- LocalStorage Keys ---
            const STORAGE_KEY = 'transformTester_savedTransitions';


            // --- LocalStorage Helpers ---
            function getSavedTransitions() {
                const saved = localStorage.getItem(STORAGE_KEY);
                return saved ? JSON.parse(saved) : [];
            }

            function saveTransitions(transitions) {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(transitions));
            }

            // --- Waypoint Counter Update --- //
            function updateWaypointCounter() {
                const count = intermediatePoints.length;
                waypointCounter.textContent = count;
                const isDisabled = count === 0;
                
                // Update the Delete button state
                deleteLastWaypointButton.disabled = isDisabled;
                
                // Handle pointer events to prevent any mouse interaction when disabled
                if (isDisabled) {
                    deleteLastWaypointButton.style.pointerEvents = 'none';
                    deleteLastWaypointButton.style.opacity = '0.5';
                    deleteLastWaypointButton.style.cursor = 'not-allowed';
                } else {
                    deleteLastWaypointButton.style.pointerEvents = 'auto';
                    deleteLastWaypointButton.style.opacity = '1';
                    deleteLastWaypointButton.style.cursor = 'pointer';
                }
                
                // Cap the maximum number of waypoints
                addWaypointButton.disabled = count >= 99;
                
                console.log(`Waypoint counter updated: ${count} points`);
            }

            // --- Theming --- //
            function applyTheme(theme) {
                const htmlElement = document.documentElement; // Target <html> tag
                if (theme === 'dark') {
                    htmlElement.classList.add('dark-theme');
                } else {
                    htmlElement.classList.remove('dark-theme');
                }
                localStorage.setItem('transformTesterTheme', theme);
            }

            // --- Render Saved List ---
            function renderSavedList() {
                const transitions = getSavedTransitions();
                savedListUl.innerHTML = ''; // Clear existing list
                selectedSavedTransitionId = null; // Clear selection
                selectedControlsDiv.style.display = 'none'; // Hide controls

                if (transitions.length === 0) {
                    savedListUl.innerHTML = '<li>No transitions saved yet.</li>';
                    return;
                }

                transitions.forEach(t => {
                    const li = document.createElement('li');
                    li.dataset.id = t.id;

                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'transition-name';
                    nameSpan.textContent = t.name;
                    li.appendChild(nameSpan);

                    // Simple indication of complexity (optional)
                    const detailsSpan = document.createElement('span');
                    detailsSpan.style.fontSize = '0.8em';
                    detailsSpan.style.color = '#6c757d';
                    detailsSpan.textContent = `(${t.points.length} pts)`;
                    li.appendChild(detailsSpan);

                    li.addEventListener('click', () => {
                        // Remove selected class from previous
                        Array.from(savedListUl.querySelectorAll('li.selected')).forEach(el => el.classList.remove('selected'));

                        // Toggle selection
                        if (selectedSavedTransitionId === t.id) {
                            selectedSavedTransitionId = null;
                            selectedControlsDiv.style.display = 'none';
                        } else {
                            selectedSavedTransitionId = t.id;
                            li.classList.add('selected');
                            renameInput.value = t.name; // Pre-fill rename input
                            selectedControlsDiv.style.display = 'block';
                            console.log('Selected saved transition:', t.id);
                        }
                    });
                    savedListUl.appendChild(li);
                });
            }

            // --- Bezier/Spline Calculation Helpers ---
            // Calculates control points for a segment p1-p2 based on neighbors p0, p3 and tension
            function getControlPoints(p0, p1, p2, p3, tension = 0.5) {
                // Catmull-Rom to Cubic Bezier conversion formula
                const d1x = (p2.x - p0.x) * tension;
                const d1y = (p2.y - p0.y) * tension;
                const d2x = (p3.x - p1.x) * tension;
                const d2y = (p3.y - p1.y) * tension;

                const cp1 = { x: p1.x + d1x / 3, y: p1.y + d1y / 3 };
                const cp2 = { x: p2.x - d2x / 3, y: p2.y - d2y / 3 };
                return [cp1, cp2];
            }

            // Calculates a point on a cubic Bezier curve defined by p0, cp1, cp2, p1 at time t (0-1)
            function getPointOnCubicBezier(p0, cp1, cp2, p1, t) {
                const t2 = t * t;
                const t3 = t2 * t;
                const mt = 1 - t;
                const mt2 = mt * mt;
                const mt3 = mt2 * mt;

                const x = mt3 * p0.x + 3 * mt2 * t * cp1.x + 3 * mt * t2 * cp2.x + t3 * p1.x;
                const y = mt3 * p0.y + 3 * mt2 * t * cp1.y + 3 * mt * t2 * cp2.y + t3 * p1.y;
                return { x, y };
            }

            // Generates a dense list of points along a spline path defined by the input points
            function generateSplinePath(points, samplesPerSegment = 30) {
                if (points.length < 2) return points;

                const path = [points[0]]; // Start with the first point
                const numSegments = points.length - 1;

                for (let i = 0; i < numSegments; i++) {
                    const p0 = points[Math.max(0, i - 1)]; // Previous point (or p0 if i=0)
                    const p1 = points[i];                     // Start of segment
                    const p2 = points[i + 1];                 // End of segment
                    const p3 = points[Math.min(numSegments, i + 2)]; // Next point (or pN if i=N-1)

                    const [cp1, cp2] = getControlPoints(p0, p1, p2, p3);

                    // Sample points along this cubic Bezier segment
                    for (let t = 1; t <= samplesPerSegment; t++) {
                        const sampleT = t / samplesPerSegment;
                        path.push(getPointOnCubicBezier(p1, cp1, cp2, p2, sampleT));
                    }
                }
                // Ensure the very last point is included exactly if needed (sampling might slightly miss)
                // path.push(points[points.length - 1]); // Usually sampling gets close enough
                return path;
            }

            // --- Initial Setup ---
            function initializeRects() {
                // Clear existing rects if any (for reset)
                viewport.innerHTML = '';

                // Create and Style Start Rect (Green)
                startRect = document.createElement('div'); // Assign to outer 'let' variable
                startRect.id = 'startRect';
                startRect.className = 'rect rect-start';
                startRect.textContent = 'Start';
                viewport.appendChild(startRect);
                // Center it initially
                const vpRect = viewport.getBoundingClientRect();
                 // Apply current size from inputs before getting bounding rect
                const currentWidth = parseInt(widthInput.value, 10);
                const currentHeight = parseInt(heightInput.value, 10);
                if (!isNaN(currentWidth) && currentWidth >= 10) startRect.style.width = `${currentWidth}px`;
                if (!isNaN(currentHeight) && currentHeight >= 10) startRect.style.height = `${currentHeight}px`;
                const sRect = startRect.getBoundingClientRect(); // Get bounds after setting size
                const initialX = (vpRect.width - sRect.width) / 2;
                const initialY = (vpRect.height - sRect.height) / 2;
                startRect.style.left = `${initialX}px`;
                startRect.style.top = `${initialY}px`;
                startRect.style.transform = ''; // Reset transform

                // Create and Style End Rect (Red) - initially same as start
                endRect = document.createElement('div'); // Assign to outer 'let' variable
                endRect.id = 'endRect';
                endRect.className = 'rect rect-end';
                endRect.textContent = 'End';
                // Apply current size
                if (!isNaN(currentWidth) && currentWidth >= 10) endRect.style.width = `${currentWidth}px`;
                if (!isNaN(currentHeight) && currentHeight >= 10) endRect.style.height = `${currentHeight}px`;
                viewport.appendChild(endRect);
                endRect.style.left = `${initialX}px`;
                endRect.style.top = `${initialY}px`;
                endRect.style.transform = ''; // Reset transform

                console.log('Rects Initialized at:', initialX, initialY);
                // Clear old intermediate points
                intermediatePoints.forEach(p => p.element.remove());
                intermediatePoints = [];
                selectedPointIndex = -1;
                isAddingPoints = false;
                addWaypointButton.textContent = 'Add';
                addWaypointButton.style.backgroundColor = '#28a745';
                // Reset viewport cursor if it was crosshair
                viewport.style.cursor = 'default';

                 // Re-attach drag listener
                 if (startRect) makeDraggable(startRect);
                 if (endRect) makeDraggable(endRect);

                 // Reset current transition state
                 currentTransitionName = "New Transition";
                 currentTransitionId = null;
                 currentTransitionHasRun = false;
                 startButton.textContent = 'Start Transition'; // Reset button text
            }

            // --- Dragging Logic ---
            function makeDraggable(element) {
                let isDragging = false;
                let startX, startY, initialMouseX, initialMouseY;

                element.addEventListener('mousedown', (e) => {
                    // Ensure element is valid
                    if (!element) return;
                    isDragging = true;
                    element.style.cursor = 'grabbing';
                    element.style.transition = 'none'; // Disable transition during drag

                    // Record initial position of the element and mouse
                    const rect = element.getBoundingClientRect();
                    const viewportRect = viewport.getBoundingClientRect();

                    // Positions relative to viewport top-left
                    startX = rect.left - viewportRect.left;
                    startY = rect.top - viewportRect.top;
                    initialMouseX = e.clientX;
                    initialMouseY = e.clientY;

                    // Prevent default drag behavior (like selecting text)
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging || !element) return;

                    // Calculate mouse movement
                    const dx = e.clientX - initialMouseX;
                    const dy = e.clientY - initialMouseY;

                    // Calculate new position
                    let newX = startX + dx;
                    let newY = startY + dy;

                    // Constrain within viewport bounds
                    const vpRect = viewport.getBoundingClientRect();
                    const elRect = element.getBoundingClientRect();
                    newX = Math.max(0, Math.min(newX, vpRect.width - elRect.width));
                    newY = Math.max(0, Math.min(newY, vpRect.height - elRect.height));

                    element.style.left = `${newX}px`;
                    element.style.top = `${newY}px`;
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging && element) {
                        isDragging = false;
                        element.style.cursor = 'grab';
                        element.style.transition = ''; // Re-enable transition
                        console.log(`${element.id} Dropped at:`, element.style.left, element.style.top);
                    }
                });
                 // Prevent dragging the element itself (browser default)
                 element.addEventListener('dragstart', (e) => {
                    e.preventDefault();
                });
            }

             // --- Reset Button ---
            resetButton.addEventListener('click', initializeRects);

             // --- Resize Logic ---
            function applyRectangleSize() {
                const newWidth = parseInt(widthInput.value, 10);
                const newHeight = parseInt(heightInput.value, 10);

                // Enforce limits: 50px minimum, 400px maximum
                const validWidth = Math.max(50, Math.min(400, newWidth));
                const validHeight = Math.max(50, Math.min(400, newHeight));
                
                // Update input values if they were clamped
                if (validWidth !== newWidth) {
                    widthInput.value = validWidth;
                }
                if (validHeight !== newHeight) {
                    heightInput.value = validHeight;
                }

                if (isNaN(validWidth) || isNaN(validHeight)) {
                    console.warn('Invalid rectangle dimensions');
                    return;
                }

                // Get viewport bounds for validation
                const vpRect = viewport.getBoundingClientRect();

                // Resize both rectangles while maintaining their current centers
                [startRect, endRect].forEach(rect => {
                    if (!rect) return;
                    
                    // Get current position and size
                    const currentLeft = parseFloat(rect.style.left) || 0;
                    const currentTop = parseFloat(rect.style.top) || 0;
                    const currentWidth = rect.offsetWidth;
                    const currentHeight = rect.offsetHeight;
                    
                    // Calculate current center point
                    const centerX = currentLeft + (currentWidth / 2);
                    const centerY = currentTop + (currentHeight / 2);
                    
                    // Apply new size
                    rect.style.width = `${validWidth}px`;
                    rect.style.height = `${validHeight}px`;
                    
                    // Reposition to maintain the same center
                    const newLeft = centerX - (validWidth / 2);
                    const newTop = centerY - (validHeight / 2);
                    
                    // Keep within viewport bounds
                    const boundedLeft = Math.max(0, Math.min(newLeft, vpRect.width - validWidth));
                    const boundedTop = Math.max(0, Math.min(newTop, vpRect.height - validHeight));
                    
                    rect.style.left = `${boundedLeft}px`;
                    rect.style.top = `${boundedTop}px`;
                });

                console.log(`Resized rectangles to ${validWidth}x${validHeight} while maintaining centers`);
            }

            // Add event listeners for interactive updates
            widthInput.addEventListener('change', applyRectangleSize);
            heightInput.addEventListener('change', applyRectangleSize);
            // Input event for real-time updates as user types or uses spinner
            widthInput.addEventListener('input', applyRectangleSize);
            heightInput.addEventListener('input', applyRectangleSize);

            // Load saved theme on startup - Add this line back
            const savedTheme = localStorage.getItem('transformTesterTheme') || 'light';

            // --- Set up rotation button event handlers --- //
            function setupRotationControls() {
                // Select all rotation button groups
                const directionToggles = document.querySelectorAll('.direction-toggle');
                
                directionToggles.forEach(toggle => {
                    const axis = toggle.getAttribute('data-axis');
                    const buttons = toggle.querySelectorAll('.btn-dir');
                    
                    buttons.forEach(button => {
                        button.addEventListener('click', () => {
                            // Remove active class from all buttons in this toggle
                            buttons.forEach(b => b.classList.remove('active'));
                            
                            // Add active class to clicked button
                            button.classList.add('active');
                            
                            // Get the value from the button's data attribute
                            const value = parseInt(button.getAttribute('data-value'), 10);
                            
                            // Update the corresponding rotation direction variable
                            if (axis === 'x') {
                                xRotationDirection = value;
                                console.log(`X rotation direction set to: ${value}`);
                            } else if (axis === 'y') {
                                yRotationDirection = value;
                                console.log(`Y rotation direction set to: ${value}`);
                            } else if (axis === 'z') {
                                zRotationDirection = value;
                                console.log(`Z rotation direction set to: ${value}`);
                            }
                            
                            // Update the data-direction attribute on the parent toggle
                            toggle.setAttribute('data-direction', value);
                        });
                    });
                });
                
                console.log("Rotation control event handlers set up");
            }

            // --- Duration Control Setup --- //
            function setupDurationControl() {
                // Set constraints for animation duration
                const MIN_DURATION = 100; // ms
                const MAX_DURATION = 5000; // ms
                const DEFAULT_DURATION = 500; // ms
                
                // Update input attributes to match constraints
                durationInput.min = MIN_DURATION;
                durationInput.max = MAX_DURATION;
                durationInput.step = 50;
                
                // Ensure initial value is within range
                const initialValue = parseInt(durationInput.value, 10);
                if (isNaN(initialValue) || initialValue < MIN_DURATION || initialValue > MAX_DURATION) {
                    durationInput.value = DEFAULT_DURATION;
                }
                
                // Create and add duration feedback element
                const durationFeedback = document.createElement('span');
                durationFeedback.id = 'durationFeedback';
                durationFeedback.style.marginLeft = '8px';
                durationFeedback.style.fontSize = '0.9em';
                durationFeedback.style.color = 'var(--text-color-secondary)';
                durationInput.parentNode.appendChild(durationFeedback);
                
                // Update feedback text
                function updateDurationFeedback() {
                    const value = parseInt(durationInput.value, 10);
                    if (!isNaN(value)) {
                        const seconds = (value / 1000).toFixed(1);
                        durationFeedback.textContent = `(${seconds}s)`;
                        durationFeedback.style.color = 'var(--text-color-secondary)';
                    } else {
                        durationFeedback.textContent = '(invalid)';
                        durationFeedback.style.color = '#dc3545'; // Error color
                    }
                }
                
                // Validate and correct input
                function validateDuration() {
                    let value = parseInt(durationInput.value, 10);
                    
                    if (isNaN(value)) {
                        value = DEFAULT_DURATION;
                    } else {
                        // Clamp value to min/max range
                        value = Math.max(MIN_DURATION, Math.min(MAX_DURATION, value));
                    }
                    
                    // Update input if value changed
                    if (value !== parseInt(durationInput.value, 10)) {
                        durationInput.value = value;
                    }
                    
                    updateDurationFeedback();
                    return value;
                }
                
                // Event listeners
                durationInput.addEventListener('change', validateDuration);
                durationInput.addEventListener('input', updateDurationFeedback);
                
                // Initial feedback update
                updateDurationFeedback();
                
                console.log("Duration control set up with range:", MIN_DURATION, "-", MAX_DURATION, "ms");
            }

            // --- Viewport Action Buttons Setup --- //
            function setupViewportActions() {
                // Extract animation logic into a reusable function
                function animateTransition(isReplay = false) {
                    console.log(`${isReplay ? "Replaying" : "Starting"} transition...`);
                    
                    // Validate rectangle elements
                    if (!startRect || !endRect) {
                        console.error("Start/End rectangle elements not found!");
                        return;
                    }
                    
                    // Assign name/ID on first run if needed
                    if (!currentTransitionHasRun && !isReplay) {
                        if (currentTransitionName === "New Transition") {
                            currentTransitionId = Date.now();
                            currentTransitionName = `Transition ${new Date(currentTransitionId).toLocaleString()}`;
                        }
                        // If it has a custom name but no ID, assign ID now
                        else if (!currentTransitionId) {
                            currentTransitionId = Date.now();
                        }
                        currentTransitionHasRun = true;
                    }
                    
                    // Update button text
                    startButton.textContent = 'Run Again';
                    
                    // Get validated duration
                    const duration = parseInt(durationInput.value, 10);
                    const durationSeconds = Math.max(0.1, duration / 1000); // Ensure minimum duration
                    
                    // Get Start/End Positions relative to viewport
                    const startRectBounds = startRect.getBoundingClientRect();
                    const endRectBounds = endRect.getBoundingClientRect();
                    const vpRect = viewport.getBoundingClientRect();
                    
                    const startLeft = startRectBounds.left - vpRect.left;
                    const startTop = startRectBounds.top - vpRect.top;
                    const endLeft = endRectBounds.left - vpRect.left;
                    const endTop = endRectBounds.top - vpRect.top;
                    
                    // Calculate Translation
                    const translateX = endLeft - startLeft;
                    const translateY = endTop - startTop;
                    
                    // --- Intermediate Points & Keyframes ---
                    const controlPoints = [
                        { x: startLeft, y: startTop }, // Start point
                        ...intermediatePoints.map(p => ({ x: p.x, y: p.y })), // Intermediate points
                        { x: endLeft, y: endTop } // End point
                    ];
                    
                    // Generate a smooth path through the points
                    const smoothPath = generateSplinePath(controlPoints);
                    
                    // Create keyframe animation for complex paths
                    if (smoothPath.length > 1) {
                        const keyframesName = `pathAnimation_${Date.now()}`;
                        let keyframesRule = `@keyframes ${keyframesName} {\n`;
                        const numPathPoints = smoothPath.length - 1;
                        
                        // Generate keyframes based on the smooth path
                        smoothPath.forEach((point, index) => {
                            const percentage = (index / numPathPoints) * 100;
                            // Translate relative to the *initial* start position
                            const pointTranslateX = point.x - startLeft;
                            const pointTranslateY = point.y - startTop;
                            // Interpolate rotation based on overall percentage
                            const rotateXValue = xRotationDirection * 360 * (percentage / 100);
                            const rotateYValue = yRotationDirection * 360 * (percentage / 100);
                            const rotateZValue = zRotationDirection * 360 * (percentage / 100);
                            
                            const transformValue = `translateX(${pointTranslateX}px) translateY(${pointTranslateY}px) rotateX(${rotateXValue}deg) rotateY(${rotateYValue}deg) rotateZ(${rotateZValue}deg)`;
                            keyframesRule += `  ${percentage}% { transform: ${transformValue}; }\n`;
                        });
                        
                        keyframesRule += `}`;
                        
                        // Inject keyframes into a style tag
                        const styleSheet = document.createElement("style");
                        styleSheet.textContent = keyframesRule;
                        document.head.appendChild(styleSheet);
                        
                        // Apply animation
                        startRect.style.animation = `${keyframesName} ${durationSeconds}s ease-in-out forwards`; // Keep end state
                        
                        // Clean up style tag and animation property after completion
                        setTimeout(() => {
                            startRect.style.animation = '';
                            startRect.style.transform = '';
                            styleSheet.remove(); // Remove the style element when done
                        }, duration + 100); // Add small buffer for animation completion
                    } else {
                        // Fallback to simple transition if no intermediate points
                        const transformValue = `translateX(${translateX}px) translateY(${translateY}px) rotateX(${xRotationDirection*360}deg) rotateY(${yRotationDirection*360}deg) rotateZ(${zRotationDirection*360}deg)`;
                        startRect.style.transition = `transform ${durationSeconds}s ease-in-out`;
                        startRect.style.transform = transformValue;
                        
                        // Reset after transition
                        setTimeout(() => {
                            startRect.style.transform = '';
                            startRect.style.transition = '';
                        }, duration + 100);
                    }
                }
                
                // --- Start Button Event Handler ---
                startButton.addEventListener('click', () => {
                    animateTransition(false);
                });
                
                // --- Replay Button Event Handler ---
                replayButton.addEventListener('click', () => {
                    // Reset rectangle position before replay
                    startRect.style.animation = '';
                    startRect.style.transform = '';
                    
                    // Small delay before starting animation to ensure reset took effect
                    setTimeout(() => {
                        animateTransition(true);
                    }, 50);
                });
                
                // --- Reset Button Event Handler ---
                resetButton.addEventListener('click', () => {
                    // Clear any ongoing animations
                    if (startRect) {
                        startRect.style.animation = '';
                        startRect.style.transform = '';
                        startRect.style.transition = '';
                    }
                    
                    // Reinitialize rectangles
                    initializeRects();
                    
                    console.log("Viewport reset complete");
                });
                
                console.log("Viewport action buttons set up");
            }

            // --- Waypoint Controls Setup --- //
            function setupWaypointControls() {
                // Style Add button for permanent WAM mode
                function styleAddButton() {
                    addWaypointButton.textContent = 'Add +';
                    addWaypointButton.style.backgroundColor = '#007bff'; // Standard button blue
                    addWaypointButton.style.borderColor = '#0056b3'; // Darker blue border
                    viewport.style.cursor = 'crosshair'; // Always show crosshair in viewport
                }
                
                // Function to add a waypoint when clicked in the viewport
                function addWaypoint(clientX, clientY) {
                    const vpRect = viewport.getBoundingClientRect();
                    const x = clientX - vpRect.left;
                    const y = clientY - vpRect.top;
                    
                    // Create a visual marker for the waypoint
                    const marker = document.createElement('div');
                    marker.className = 'point-marker';
                    marker.style.left = `${x}px`;
                    marker.style.top = `${y}px`;
                    viewport.appendChild(marker);
                    
                    // Store waypoint data
                    const pointData = { x, y, element: marker };
                    intermediatePoints.push(pointData);
                    
                    // Set as the last modified point
                    lastModifiedPointIndex = intermediatePoints.length - 1;
                    
                    // Make marker draggable and selectable
                    makeDraggableWaypoint(marker, intermediatePoints.length - 1);
                    
                    // Update counter and Del button state
                    updateWaypointCounter();
                    
                    console.log(`Added waypoint at (${x}, ${y})`);
                    return pointData;
                }
                
                // Function to delete the most recently modified waypoint
                function deleteLastWaypoint() {
                    if (intermediatePoints.length === 0) return;
                    
                    // Determine which point to delete
                    const indexToDelete = (lastModifiedPointIndex >= 0 && lastModifiedPointIndex < intermediatePoints.length) 
                        ? lastModifiedPointIndex 
                        : intermediatePoints.length - 1; // Fallback to last point
                    
                    // Get the point to delete
                    const pointToDelete = intermediatePoints[indexToDelete];
                    
                    // Remove the point from the array using splice
                    intermediatePoints.splice(indexToDelete, 1);
                    
                    // Remove the visual marker
                    if (pointToDelete.element) {
                        pointToDelete.element.remove();
                    }
                    
                    // Update indexes after deletion
                    if (lastModifiedPointIndex >= intermediatePoints.length) {
                        lastModifiedPointIndex = intermediatePoints.length - 1;
                    }
                    
                    // Update the counter and Del button state
                    updateWaypointCounter();
                    
                    console.log(`Deleted waypoint at index ${indexToDelete}`);
                }
                
                // Make waypoint draggable
                function makeDraggableWaypoint(element, index) {
                    let isDragging = false;
                    
                    element.addEventListener('mousedown', (e) => {
                        // Remove this check to allow dragging in WAM mode
                        // if (isAddingPoints) return;
                        
                        isDragging = true;
                        draggingPointIndex = index;
                        lastModifiedPointIndex = index; // Update last modified point
                        wasDraggingPoint = false;
                        
                        // Get initial positions for drag calculation
                        const vpRect = viewport.getBoundingClientRect();
                        dragOffsetX = e.clientX - (vpRect.left + intermediatePoints[index].x);
                        dragOffsetY = e.clientY - (vpRect.top + intermediatePoints[index].y);
                        
                        // Select this point and deselect others
                        intermediatePoints.forEach((p, i) => {
                            if (p.element) {
                                if (i === index) {
                                    p.element.classList.add('selected');
                                } else {
                                    p.element.classList.remove('selected');
                                }
                            }
                        });
                        
                        selectedPointIndex = index;
                        e.stopPropagation(); // Prevent viewport click
                        e.preventDefault();
                    });
                    
                    // Handle point movement in global mouse handlers
                }
                
                // Event: Viewport click to add waypoint
                viewport.addEventListener('click', (e) => {
                    // Don't add waypoint if we just finished dragging
                    if (wasDraggingPoint) {
                        wasDraggingPoint = false;
                        return;
                    }
                    
                    // Also don't add waypoint if clicked on an existing waypoint
                    if (e.target.classList.contains('point-marker')) {
                        return;
                    }
                    
                    addWaypoint(e.clientX, e.clientY);
                });
                
                // Event: Add button click
                addWaypointButton.addEventListener('click', () => {
                    // Simply display a message in the console - button now only serves as a label
                    console.log('Add button clicked - you can click anywhere in the viewport to add waypoints');
                });
                
                // Event: Delete last waypoint button
                deleteLastWaypointButton.addEventListener('click', () => {
                    deleteLastWaypoint();
                });
                
                // Apply WAM styling
                styleAddButton();
                
                // Global mouse move for dragging waypoints
                document.addEventListener('mousemove', (e) => {
                    if (draggingPointIndex >= 0 && draggingPointIndex < intermediatePoints.length) {
                        wasDraggingPoint = true; // Set flag to prevent click after drag
                        
                        const vpRect = viewport.getBoundingClientRect();
                        const newX = e.clientX - vpRect.left - dragOffsetX;
                        const newY = e.clientY - vpRect.top - dragOffsetY;
                        
                        // Remove constraints - allow dragging outside viewport
                        // const constrainedX = Math.max(0, Math.min(newX, vpRect.width));
                        // const constrainedY = Math.max(0, Math.min(newY, vpRect.height));
                        
                        // Update point position
                        intermediatePoints[draggingPointIndex].x = newX;
                        intermediatePoints[draggingPointIndex].y = newY;
                        
                        // Update visual marker
                        const marker = intermediatePoints[draggingPointIndex].element;
                        if (marker) {
                            marker.style.left = `${newX}px`;
                            marker.style.top = `${newY}px`;
                        }
                    }
                });
                
                // Global mouse up to end waypoint dragging
                document.addEventListener('mouseup', (e) => {
                    if (draggingPointIndex >= 0) {
                        // Check if the point is outside the viewport
                        const vpRect = viewport.getBoundingClientRect();
                        const point = intermediatePoints[draggingPointIndex];
                        
                        // Calculate if point is outside viewport boundaries
                        const isOutside = 
                            point.x < -20 || // Allow slight margin outside
                            point.y < -20 || 
                            point.x > vpRect.width + 20 || 
                            point.y > vpRect.height + 20;
                        
                        if (isOutside) {
                            // Remove the point from the array
                            const removedPoint = intermediatePoints.splice(draggingPointIndex, 1)[0];
                            
                            // Remove the visual marker
                            if (removedPoint.element) {
                                removedPoint.element.remove();
                            }
                            
                            // Update last modified index after deletion
                            if (draggingPointIndex <= lastModifiedPointIndex) {
                                lastModifiedPointIndex = Math.max(0, lastModifiedPointIndex - 1);
                            }
                            
                            // Update counter
                            updateWaypointCounter();
                            
                            // Reset dragging flag to allow immediate waypoint creation
                            wasDraggingPoint = false;
                            
                            console.log('Waypoint deleted by dragging outside viewport');
                        } else {
                            // Point is still within viewport - update last modified
                            lastModifiedPointIndex = draggingPointIndex;
                            
                            // Remove selected styling
                            if (point && point.element) {
                                point.element.classList.remove('selected');
                            }
                            
                            // Constrain final position to within viewport
                            point.x = Math.max(0, Math.min(point.x, vpRect.width));
                            point.y = Math.max(0, Math.min(point.y, vpRect.height));
                            
                            // Update visual marker with constrained position
                            if (point.element) {
                                point.element.style.left = `${point.x}px`;
                                point.element.style.top = `${point.y}px`;
                            }
                        }
                        
                        // Reset the dragging index
                        draggingPointIndex = -1;
                        selectedPointIndex = -1; // Clear selection
                    }
                });
                
                console.log("Waypoint controls set up - permanently in WAM mode");
            }

            // --- Initial Call --- //
            initializeRects();
            renderSavedList();
            applyTheme(savedTheme);
            updateWaypointCounter(); // Set initial counter and Del button state
            setupRotationControls(); // Set up rotation control event handlers
            setupDurationControl(); // Set up duration control
            setupViewportActions(); // Set up viewport action buttons
            setupWaypointControls(); // Set up waypoint controls - will enable permanent WAM
            
            // No need to toggle WAM mode since we're always in WAM
            // setTimeout(() => {
            //     addWaypointButton.click();
            //     console.log('Initialized in Waypoint Adding Mode');
            // }, 500);
            
            // Add this listener if it was accidentally removed
            themeToggleButton.addEventListener('click', () => {
                console.log("Theme toggle clicked!"); // Check listener firing
                const currentTheme = document.documentElement.classList.contains('dark-theme') ? 'dark' : 'light';
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                applyTheme(newTheme);
            });
 
        });
    </script>
</body>
</html>
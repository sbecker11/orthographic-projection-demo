<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XForm Tester</title>
    <style>
        body {
            margin: 20px;
            font-family: Arial, sans-serif;
            background-color: var(--bg-color-primary);
            color: var(--text-color-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh; /* Ensure body takes full height */
        }
        .three-column-layout {
            display: flex;
            gap: 20px;
            width: 100%;
            max-width: 1100px; /* Reduced max-width */
            align-items: flex-start; /* Align items to the top */
            position: relative; /* Needed for viewport-actions positioning */
        }
        .left-column, .right-column {
            flex: 1; /* Allow left and right columns to grow */
            min-width: 220px; /* Reduced min-width */
            padding: 20px;
            background-color: var(--bg-color-secondary);
            border-radius: 8px;
            box-shadow: var(--shadow-elevation-low);
            height: fit-content; /* Adjust height based on content */
            border: none; /* Remove previous border, use fieldset */
            display: flex; /* Use flexbox for children */
            flex-direction: column; /* Stack fieldsets vertically */
            gap: 15px; /* Space between fieldsets */
        }
        .center-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            position: relative; /* Positioning context for theme toggle */
            padding-top: 44px; /* toggle height (24) + desired gap (20) */
        }
        #viewport {
            position: relative; /* Needed for absolute positioning of rects */
            background-color: white; /* Keep background */
            border-radius: 8px;
            /* Bevel effect */
            border: 1px solid #aaa;
            box-shadow: inset 3px 3px 6px rgba(0,0,0,0.2),
                        inset -2px -2px 5px rgba(255,255,255,0.6),
                        0 4px 8px rgba(0,0,0,0.15); /* Optional outer shadow */
            overflow: hidden;
            width: 400px; /* Reduced width */
            height: 400px; /* Reduced height */
            perspective: 1000px; /* Enable 3D space for children */
        }
        .rect {
            position: absolute;
            width: 100px;
            height: 60px;
            border-radius: 4px;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px black;
            box-sizing: border-box; /* Include padding/border in element's total width and height */
            transform-style: preserve-3d; /* Important for containing 3D transforms */
            transition: transform 0.5s ease-in-out; /* Default transition */
        }
        .rect-start {
            background-color: rgba(0, 128, 0, 0.8); /* Green, semi-transparent */
            border: 2px solid darkgreen;
            z-index: 1; /* Start rect below */
            cursor: grab; /* Make it grabbable */
            position: absolute; /* Keep absolute positioning */
        }
        .rect-end {
            background-color: rgba(255, 0, 0, 0.8); /* Red, semi-transparent */
            border: 2px solid darkred;
            z-index: 2; /* End rect above, draggable */
            position: absolute; /* Keep absolute positioning */
        }
        .rect-end:active {
            cursor: grabbing;
        }
        .controls-column h2,
        .persistence-column h2 {
            margin-top: 0;
            margin-bottom: 10px; /* Space below H2 inside fieldset */
            font-size: 1.1em; /* Slightly smaller H2 */
        }
        fieldset {
            /* border: 1px solid var(--border-color-strong); Remove border */
            border: none;
            border-radius: 6px;
            padding: 15px;
            margin: 0; /* Reset default fieldset margin */
            width: 100%; /* Take full width of parent column */
            box-sizing: border-box;
        }
        /* legend {
            padding: 0 5px;
            font-weight: bold;
            color: var(--text-color-primary);
            margin-left: 10px; 
            font-size: 1em;
        } */

        /* Style the new labels as section headers */
        .control-section > label {
            display: block; /* Make label take full width */
            font-weight: bold;
            margin-bottom: 10px; /* Space below label */
            font-size: 1.1em;
            color: var(--text-color-primary);
        }

        .control-section {
            /* padding: 2px 0; Further reduce vertical padding */
            padding: 0; /* Remove padding, rely on gap */
        }

        .control-group {
             margin-bottom: 5px; /* Further reduce space */
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="number"], input[type="text"] {
            width: calc(100% - 16px);
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button.secondary {
            background-color: #6c757d;
        }
        button.secondary:hover {
            background-color: #5a6268;
        }
         button.danger {
            background-color: #dc3545;
        }
        button.danger:hover {
            background-color: #c82333;
        }
        #savedList { /* Target the ul directly */
            list-style: none;
            padding: 0;
            max-height: 300px; /* Keep max-height */
            overflow-y: auto;
        }
         #savedList li { /* Target li directly */
            padding: 10px;
            border: 1px solid #eee;
            margin-bottom: 5px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        .saved-transitions li:hover {
            background-color: #f8f9fa;
        }
        .saved-transitions li.selected {
            background-color: #e0e0e0;
            font-weight: bold;
        }
        .transition-name {
             flex-grow: 1;
             margin-right: 10px;
             overflow: hidden;
             text-overflow: ellipsis;
             white-space: nowrap;
        }
        .direction-toggle span:first-child { /* Target the label span specifically */
            display: inline-block;
            width: 30px; /* Fixed width for alignment */
            color: var(--text-color-primary);
        }
        .rot-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            margin-left: 0px; /* Remove left margin */
            margin-right: 8px;
            vertical-align: middle;
            background-size: contain; /* Or 16px 16px */
            background-repeat: no-repeat;
            background-position: center;
        }
        .rot-icon[data-axis="x"] { background-image: url('icons/x-rot.png'); }
        .rot-icon[data-axis="y"] { background-image: url('icons/y-rot.png'); }
        .rot-icon[data-axis="z"] { background-image: url('icons/z-rot.png'); }
        body.dark-theme .rot-icon[data-axis="x"] { background-image: url('icons/x-rot-dark.png'); }
        body.dark-theme .rot-icon[data-axis="y"] { background-image: url('icons/y-rot-dark.png'); }
        body.dark-theme .rot-icon[data-axis="z"] { background-image: url('icons/z-rot-dark.png'); }
        .direction-toggle button {
            padding: 5px 0; /* Adjust padding for consistent height */
            font-size: 0.9em; /* Slightly smaller text */
            width: 30px; /* Fixed width for all */
            min-width: auto; /* Allow button to be smaller */
            margin-left: 5px;
            margin-bottom: 5px; /* Add bottom margin */
            text-align: center;
            line-height: 1.2; /* Adjust for vertical centering */
        }
        .direction-toggle button.active {
            background-color: #28a745; /* Green for active */
            border: 1px solid #1e7e34;
            opacity: 1.0;
        }
        .direction-toggle button:not(.active) {
            background-color: #6c757d; /* Grey for inactive */
            opacity: 0.7;
        }
        /* Specific style for active zero button */
        .direction-toggle button[data-value="0"].active {
             background-color: #ffc107; /* Yellow for zero */
             color: #333;
             border-color: #e0a800;
             opacity: 1.0;
        }
        .point-marker {
            position: absolute;
            width: 15px;
            height: 15px;
            background-color: rgba(0, 0, 255, 0.7);
            border: 1px solid darkblue;
            border-radius: 50%;
            cursor: pointer;
            transform: translate(-50%, -50%); /* Center the marker on the click point */
            z-index: 3; /* Above rects */
        }
        .point-marker.selected {
            background-color: rgba(0, 255, 255, 0.9); /* Cyan when selected */
            border: 2px solid teal;
        }

        /* Header */
        .app-header {
            width: 100%;
            display: flex;
            /* justify-content: space-between; Let button be positioned independently */
            align-items: center;
            padding: 10px 20px;
            box-sizing: border-box;
            /* margin-bottom: 15px; Reduce space below header */
            margin-bottom: 5px;
        }
        .app-header h1 {
            margin: 0;
            flex-grow: 1;
            margin-bottom: 10px; /* Add some space below title */
        }

        #themeToggle {
            position: absolute;
            top: 0px;  /* Position at the top of the center column's padding */
            right: 0;    /* Align with right edge of viewport container */
            z-index: 10; /* Ensure it's clickable */
            width: 60px;
            height: 24px;
            border-radius: 12px; /* height / 2 */
            border: 1px solid var(--border-color-strong);
            background-color: var(--bg-color-toggle-off);
            cursor: pointer;
            transition: background-color 0.3s ease;
            box-sizing: border-box;
            appearance: none; /* Remove default button styles */
            /* Clear content for pseudo-element */
            color: transparent;
            font-size: 0;
            line-height: 0;
        }

        #themeToggle::before {
            content: '';
            position: absolute;
            width: 20px; /* Size of the switch circle */
            height: 20px;
            border-radius: 50%;
            background-color: var(--bg-color-toggle-switch);
            top: 1px; /* Center vertically */
            left: 1px;
            transition: transform 0.3s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        body.dark-theme #themeToggle {
            background-color: var(--bg-color-toggle-on);
        }

        body.dark-theme #themeToggle::before {
            transform: translateX(36px); /* Adjust based on size/padding */
        }

        /* Layout */
        .three-column-layout {
            display: flex;
            gap: 20px;
            width: 100%;
            max-width: 1100px; /* Reduced max-width */
            align-items: flex-start; /* Align items to the top */
            position: relative; /* Needed for viewport-actions positioning */
        }

        /* Block size controls row */
        .block-size-controls {
            display: flex;
            align-items: center;
            gap: 5px; /* Reduced gap */
            /* Calculate total width similar to duration */
            /* Label width can be flexible */
        }
        .block-size-controls label {
             margin-bottom: 0; /* Remove bottom margin for inline label */
             white-space: nowrap;
             flex-shrink: 0; /* Prevent label from shrinking */
             margin-right: auto; /* Push inputs/button to the right */
             line-height: 28px; /* Align label vertically */
        }
        .block-size-controls input[type="number"] {
             width: 57px; /* Increased width */
             margin-bottom: 0;
             height: 100%; /* Match parent height */
             box-sizing: border-box;
             margin-right: 5px; /* Add right margin */
        }
        .block-size-controls span { /* The 'x' */
            margin: 0 2px;
        }
        .block-size-controls button {
            margin-bottom: 0;
            flex-shrink: 0; /* Prevent button from shrinking */
            padding: 10px 8px; /* Increase top/bottom padding */
            min-width: auto; /* Allow button to be smaller */
            height: 100%; /* Match parent height */
            box-sizing: border-box;
        }

        /* Viewport Actions (Start/Replay/Reset) */
        .viewport-actions {
            display: flex;
            justify-content: center;
            gap: 10px;
            width: 100%; /* Span width below viewport */
            margin-top: 10px; /* Space above buttons */
        }

        .right-column {
            /* margin-top: -40px; Remove this adjustment for now */
        }

        .direction-toggle {
            display: flex; /* Use flexbox to keep elements in a row */
            align-items: center; /* Vertically align label, icon, buttons */
            margin-bottom: 8px; /* Space between rows */
        }

        #duration { /* Specific style for duration input */
            width: 147px; /* Adjusted for approx 20px spinner width */
            margin-left: auto; /* Push input to the right if label is short */
        }

        /* Waypoint controls row */
        .waypoint-controls {
            display: flex;
            align-items: center;
            /* padding: 0 5px; Remove padding */
            /* gap: 10px; Add gap between elements */
            gap: 6px; /* Reduce gap */
        }
        .waypoint-controls > button:first-child {
            margin-right: 0; /* Override auto margin */
        }

        .waypoint-btn { /* Class for Add/Del buttons */
            min-width: 50px; /* Ensure enough space for Add+ */
            text-align: center;
        }

        #waypointCounter {
            font-weight: bold;
            color: var(--text-color-secondary);
            /* min-width: 25px; Tighter width for 2 digits */
            min-width: 40px; /* Adjusted width */
            text-align: center;
        }

        :root {
            --bg-color-primary: #f0f0f0;
            --bg-color-secondary: #ffffff;
            --text-color-primary: #333333;
            --text-color-secondary: #666666;
            --border-color: #dddddd;
            --border-color-strong: #aaaaaa;
            --button-bg: #007bff;
            --button-hover-bg: #0056b3;
            --button-danger-bg: #dc3545;
            --button-danger-hover-bg: #c82333;
            --shadow-elevation-low: 0 1px 2px rgba(0,0,0,0.05);
            --shadow-elevation-medium: 0 4px 8px rgba(0,0,0,0.1);
            --text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            /* Theme Toggle Colors (Light) */
            --bg-color-toggle-off: #cccccc; /* Grey when off (light theme) */
            --bg-color-toggle-on: #007bff; /* Blue when on (light theme) */
            --bg-color-toggle-switch: #ffffff; /* White switch */
        }

        body.dark-theme {
            --bg-color-primary: #22272e;
            --bg-color-secondary: #2d333b;
            --text-color-primary: #cdd9e5;
            --text-color-secondary: #97a6b7;
            --border-color: #444c56;
            --border-color-strong: #586069;
            --button-bg: #3081f7;
            --button-hover-bg: #458ff7;
            --button-danger-bg: #f85149;
            --button-danger-hover-bg: #fa675f;
            --shadow-elevation-low: 0 1px 2px rgba(0,0,0,0.2);
            --shadow-elevation-medium: 0 4px 8px rgba(0,0,0,0.3);
            --text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            /* Theme Toggle Colors (Dark) */
            --bg-color-toggle-off: #586069; /* Dark grey when off (dark theme) */
            --bg-color-toggle-on: #3081f7;  /* Blue when on (dark theme) */
            --bg-color-toggle-switch: #22272e; /* Dark switch */
        }
    </style>
</head>
<body>

    <div class="app-header">
        <h1>XForm Tester</h1>
    </div>

    <div class="three-column-layout">
        <!-- Left: Persistence -->
        <div class="left-column persistence-column">
            <fieldset>
                <legend>Saved Transitions</legend>
                <ul id="savedList">
                    <!-- Saved transitions will be listed here -->
                    <li>No transitions saved yet.</li>
                </ul>
                <div class="control-group" id="selectedTransitionControls" style="display: none;">
                    <input type="text" id="renameInput" placeholder="New name">
                    <button id="renameTransition" class="secondary">Rename</button>
                    <button id="deleteTransition" class="danger">Delete</button>
                    <button id="replayTransition">Replay Selected</button>
                </div>
                <div class="control-group" style="margin-top: 15px; text-align: center;">
                    <button id="saveTransition">Save Current Configuration</button>
                </div>
            </fieldset>
        </div>

        <!-- Center: Viewport & Actions -->
        <div class="center-column">
            <button id="themeToggle" title="Toggle Theme"></button>
            <div id="viewport">
                <!-- Rectangles will be added here by JS -->
            </div>
            <div class="viewport-actions">
                <button id="startTransition">Start</button>
                <button id="replayTransitionBtn">Replay</button>
                <button id="resetPositions">Reset</button>
            </div>
        </div>

        <!-- Right: Controls -->
        <div class="right-column controls-column">
            <div class="control-section">
                <label for="rotations">Rotations:</label>
                <div class="control-group" style="margin-bottom: 5px;">
                    <div class="direction-toggle" data-axis="x" data-direction="1">
                        <span>X:</span><span class="rot-icon" data-axis="x"></span>
                        <button class="btn-dir active" data-value="1">+</button>
                        <button class="btn-dir" data-value="0">0</button>
                        <button class="btn-dir" data-value="-1">-</button>
                    </div>
                    <div class="direction-toggle" data-axis="y" data-direction="1">
                        <span>Y:</span><span class="rot-icon" data-axis="y"></span>
                        <button class="btn-dir active" data-value="1">+</button>
                        <button class="btn-dir" data-value="0">0</button>
                        <button class="btn-dir" data-value="-1">-</button>
                    </div>
                    <div class="direction-toggle" data-axis="z" data-direction="1">
                        <span>Z:</span><span class="rot-icon" data-axis="z"></span>
                        <button class="btn-dir active" data-value="1">+</button>
                        <button class="btn-dir" data-value="0">0</button>
                        <button class="btn-dir" data-value="-1">-</button>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <label for="duration">Duration (ms):</label>
                <div class="control-group">
                    <input type="number" id="duration" value="500" min="0" step="50">
                </div>
            </div>

            <div class="control-section">
                <label for="rectangle">Rectangle:</label>
                <div class="control-group block-size-controls">
                    <input type="number" id="rectWidth" value="100" min="10" max="999" title="Width">
                    <input type="number" id="rectHeight" value="60" min="10" max="999" title="Height">
                    <button id="applySize">Apply</button>
                </div>
            </div>

            <div class="control-section">
                <label for="waypoints">Waypoints:</label>
                <div class="control-group waypoint-controls">
                    <button id="addWaypointBtn" class="waypoint-btn">Add</button>
                    <span id="waypointCounter">0</span>
                    <button id="deleteLastWaypointBtn" class="danger waypoint-btn">Del</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM Loaded. Initializing XForm Tester...');

            // --- DOM Elements (Declare ONCE) ---
            const viewport = document.getElementById('viewport');
            const addWaypointButton = document.getElementById('addWaypointBtn');
            const waypointCounter = document.getElementById('waypointCounter');
            const deleteLastWaypointButton = document.getElementById('deleteLastWaypointBtn');
            const widthInput = document.getElementById('rectWidth');
            const heightInput = document.getElementById('rectHeight');
            const applySizeButton = document.getElementById('applySize');
            const durationInput = document.getElementById('duration');
            const startButton = document.getElementById('startTransition');
            const replayButton = document.getElementById('replayTransitionBtn');
            const resetButton = document.getElementById('resetPositions');
            const savedListUl = document.getElementById('savedList');
            const selectedControlsDiv = document.getElementById('selectedTransitionControls');
            const renameInput = document.getElementById('renameInput');
            const renameButton = document.getElementById('renameTransition');
            const deleteButton = document.getElementById('deleteTransition');
            const replaySavedButton = document.getElementById('replayTransition'); // In selected controls
            const currentNameDisplay = document.getElementById('currentTransitionNameDisplay');
            const editCurrentNameButton = document.getElementById('editCurrentNameBtn');
            const editCurrentNameInput = document.getElementById('editCurrentNameInput');
            const saveCurrentNameButton = document.getElementById('saveCurrentNameBtn');
            const saveButton = document.getElementById('saveTransition'); // Main save button
            const themeToggleButton = document.getElementById('themeToggle');

            // NOTE: startRect and endRect are created dynamically, so use 'let'
            let startRect = null;
            let endRect = null;

            // --- State Variables ---
            let xRotationDirection = 1;
            let yRotationDirection = 1;
            let zRotationDirection = 1;
            let isAddingPoints = false; // State flag for adding points mode
            let intermediatePoints = []; // Array to store {x, y, element} of intermediate points
            let selectedPointIndex = -1; // Index of the selected intermediate point
            let draggingPointIndex = -1; // Index of the point being dragged
            let dragOffsetX = 0; // Offset of mouse click within the dragged point
            let dragOffsetY = 0;
            let selectedSavedTransitionId = null; // ID of the selected saved transition

            // --- Current Transition State ---
            let currentTransitionName = "New Transition";
            let currentTransitionId = null; // Can be null (new) or a timestamp (run/loaded/saved)
            let currentTransitionHasRun = false;

            // --- LocalStorage Keys ---
            const STORAGE_KEY = 'transformTester_savedTransitions';


            // --- LocalStorage Helpers ---
            function getSavedTransitions() {
                const saved = localStorage.getItem(STORAGE_KEY);
                return saved ? JSON.parse(saved) : [];
            }

            function saveTransitions(transitions) {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(transitions));
            }

            // --- Render Saved List ---
            function renderSavedList() {
                const transitions = getSavedTransitions();
                savedListUl.innerHTML = ''; // Clear existing list
                selectedSavedTransitionId = null; // Clear selection
                selectedControlsDiv.style.display = 'none'; // Hide controls

                if (transitions.length === 0) {
                    savedListUl.innerHTML = '<li>No transitions saved yet.</li>';
                    return;
                }

                transitions.forEach(t => {
                    const li = document.createElement('li');
                    li.dataset.id = t.id;

                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'transition-name';
                    nameSpan.textContent = t.name;
                    li.appendChild(nameSpan);

                    // Simple indication of complexity (optional)
                    const detailsSpan = document.createElement('span');
                    detailsSpan.style.fontSize = '0.8em';
                    detailsSpan.style.color = '#6c757d';
                    detailsSpan.textContent = `(${t.points.length} pts)`;
                    li.appendChild(detailsSpan);

                    li.addEventListener('click', () => {
                        // Remove selected class from previous
                        Array.from(savedListUl.querySelectorAll('li.selected')).forEach(el => el.classList.remove('selected'));

                        // Toggle selection
                        if (selectedSavedTransitionId === t.id) {
                            selectedSavedTransitionId = null;
                            selectedControlsDiv.style.display = 'none';
                        } else {
                            selectedSavedTransitionId = t.id;
                            li.classList.add('selected');
                            renameInput.value = t.name; // Pre-fill rename input
                            selectedControlsDiv.style.display = 'block';
                            console.log('Selected saved transition:', t.id);
                        }
                    });
                    savedListUl.appendChild(li);
                });
            }

            // --- Bezier/Spline Calculation Helpers ---
            // Calculates control points for a segment p1-p2 based on neighbors p0, p3 and tension
            function getControlPoints(p0, p1, p2, p3, tension = 0.5) {
                // Catmull-Rom to Cubic Bezier conversion formula
                const d1x = (p2.x - p0.x) * tension;
                const d1y = (p2.y - p0.y) * tension;
                const d2x = (p3.x - p1.x) * tension;
                const d2y = (p3.y - p1.y) * tension;

                const cp1 = { x: p1.x + d1x / 3, y: p1.y + d1y / 3 };
                const cp2 = { x: p2.x - d2x / 3, y: p2.y - d2y / 3 };
                return [cp1, cp2];
            }

            // Calculates a point on a cubic Bezier curve defined by p0, cp1, cp2, p1 at time t (0-1)
            function getPointOnCubicBezier(p0, cp1, cp2, p1, t) {
                const t2 = t * t;
                const t3 = t2 * t;
                const mt = 1 - t;
                const mt2 = mt * mt;
                const mt3 = mt2 * mt;

                const x = mt3 * p0.x + 3 * mt2 * t * cp1.x + 3 * mt * t2 * cp2.x + t3 * p1.x;
                const y = mt3 * p0.y + 3 * mt2 * t * cp1.y + 3 * mt * t2 * cp2.y + t3 * p1.y;
                return { x, y };
            }

            // Generates a dense list of points along a spline path defined by the input points
            function generateSplinePath(points, samplesPerSegment = 30) {
                if (points.length < 2) return points;

                const path = [points[0]]; // Start with the first point
                const numSegments = points.length - 1;

                for (let i = 0; i < numSegments; i++) {
                    const p0 = points[Math.max(0, i - 1)]; // Previous point (or p0 if i=0)
                    const p1 = points[i];                     // Start of segment
                    const p2 = points[i + 1];                 // End of segment
                    const p3 = points[Math.min(numSegments, i + 2)]; // Next point (or pN if i=N-1)

                    const [cp1, cp2] = getControlPoints(p0, p1, p2, p3);

                    // Sample points along this cubic Bezier segment
                    for (let t = 1; t <= samplesPerSegment; t++) {
                        const sampleT = t / samplesPerSegment;
                        path.push(getPointOnCubicBezier(p1, cp1, cp2, p2, sampleT));
                    }
                }
                // Ensure the very last point is included exactly if needed (sampling might slightly miss)
                // path.push(points[points.length - 1]); // Usually sampling gets close enough
                return path;
            }

            // --- Initial Setup ---
            function initializeRects() {
                // Clear existing rects if any (for reset)
                viewport.innerHTML = '';

                // Create and Style Start Rect (Green)
                startRect = document.createElement('div'); // Assign to outer 'let' variable
                startRect.id = 'startRect';
                startRect.className = 'rect rect-start';
                startRect.textContent = 'Start';
                viewport.appendChild(startRect);
                // Center it initially
                const vpRect = viewport.getBoundingClientRect();
                 // Apply current size from inputs before getting bounding rect
                const currentWidth = parseInt(widthInput.value, 10);
                const currentHeight = parseInt(heightInput.value, 10);
                if (!isNaN(currentWidth) && currentWidth >= 10) startRect.style.width = `${currentWidth}px`;
                if (!isNaN(currentHeight) && currentHeight >= 10) startRect.style.height = `${currentHeight}px`;
                const sRect = startRect.getBoundingClientRect(); // Get bounds after setting size
                const initialX = (vpRect.width - sRect.width) / 2;
                const initialY = (vpRect.height - sRect.height) / 2;
                startRect.style.left = `${initialX}px`;
                startRect.style.top = `${initialY}px`;
                startRect.style.transform = ''; // Reset transform

                // Create and Style End Rect (Red) - initially same as start
                endRect = document.createElement('div'); // Assign to outer 'let' variable
                endRect.id = 'endRect';
                endRect.className = 'rect rect-end';
                endRect.textContent = 'End';
                // Apply current size
                if (!isNaN(currentWidth) && currentWidth >= 10) endRect.style.width = `${currentWidth}px`;
                if (!isNaN(currentHeight) && currentHeight >= 10) endRect.style.height = `${currentHeight}px`;
                viewport.appendChild(endRect);
                endRect.style.left = `${initialX}px`;
                endRect.style.top = `${initialY}px`;
                endRect.style.transform = ''; // Reset transform

                console.log('Rects Initialized at:', initialX, initialY);
                // Clear old intermediate points
                intermediatePoints.forEach(p => p.element.remove());
                intermediatePoints = [];
                selectedPointIndex = -1;
                isAddingPoints = false;
                addWaypointButton.textContent = 'Add+';
                addWaypointButton.style.backgroundColor = '#28a745';
                // Reset viewport cursor if it was crosshair
                viewport.style.cursor = 'default';

                 // Re-attach drag listener
                 if (startRect) makeDraggable(startRect);
                 if (endRect) makeDraggable(endRect);

                 // Reset current transition state
                 currentTransitionName = "New Transition";
                 currentTransitionId = null;
                 currentTransitionHasRun = false;
                 startButton.textContent = 'Start Transition'; // Reset button text
            }

            // --- Dragging Logic ---
            function makeDraggable(element) {
                let isDragging = false;
                let startX, startY, initialMouseX, initialMouseY;

                element.addEventListener('mousedown', (e) => {
                    // Ensure element is valid
                    if (!element) return;
                    isDragging = true;
                    element.style.cursor = 'grabbing';
                    element.style.transition = 'none'; // Disable transition during drag

                    // Record initial position of the element and mouse
                    const rect = element.getBoundingClientRect();
                    const viewportRect = viewport.getBoundingClientRect();

                    // Positions relative to viewport top-left
                    startX = rect.left - viewportRect.left;
                    startY = rect.top - viewportRect.top;
                    initialMouseX = e.clientX;
                    initialMouseY = e.clientY;

                    // Prevent default drag behavior (like selecting text)
                    e.preventDefault();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging || !element) return;

                    // Calculate mouse movement
                    const dx = e.clientX - initialMouseX;
                    const dy = e.clientY - initialMouseY;

                    // Calculate new position
                    let newX = startX + dx;
                    let newY = startY + dy;

                    // Constrain within viewport bounds
                    const vpRect = viewport.getBoundingClientRect();
                    const elRect = element.getBoundingClientRect();
                    newX = Math.max(0, Math.min(newX, vpRect.width - elRect.width));
                    newY = Math.max(0, Math.min(newY, vpRect.height - elRect.height));

                    element.style.left = `${newX}px`;
                    element.style.top = `${newY}px`;
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging && element) {
                        isDragging = false;
                        element.style.cursor = 'grab';
                        element.style.transition = ''; // Re-enable transition
                        console.log(`${element.id} Dropped at:`, element.style.left, element.style.top);
                    }
                });
                 // Prevent dragging the element itself (browser default)
                 element.addEventListener('dragstart', (e) => {
                    e.preventDefault();
                });
            }

             // --- Reset Button ---
            resetButton.addEventListener('click', initializeRects);

             // --- Resize Logic ---
            applySizeButton.addEventListener('click', () => {
                const newWidth = parseInt(widthInput.value, 10);
                const newHeight = parseInt(heightInput.value, 10);
                // Use outer scope variables startRect and endRect

                if (isNaN(newWidth) || isNaN(newHeight) || newWidth < 10 || newHeight < 10) {
                    alert('Please enter valid rectangle width and height (minimum 10px).');
                    return;
                }

                // Store previous positions to attempt recentering
                const prevStartRect = startRect ? startRect.getBoundingClientRect() : null;
                const prevEndRect = endRect ? endRect.getBoundingClientRect() : null;
                 // Viewport size is fixed, so we don't need its rect here for resizing logic
                 // const vpRect = viewport.getBoundingClientRect();

                if (startRect) {
                    startRect.style.width = `${newWidth}px`;
                    startRect.style.height = `${newHeight}px`;
                }
                if (endRect) {
                    endRect.style.width = `${newWidth}px`;
                    endRect.style.height = `${newHeight}px`;
                }

                // Attempt to reposition to maintain center (best effort)
                if (startRect && prevStartRect) {
                     const prevCenterX = (prevStartRect.left - vpRect.left) + prevStartRect.width / 2;
                     const prevCenterY = (prevStartRect.top - vpRect.top) + prevStartRect.height / 2;
                     startRect.style.left = `${prevCenterX - newWidth / 2}px`;
                     startRect.style.top = `${prevCenterY - newHeight / 2}px`;
                }
                 if (endRect && prevEndRect) {
                     const prevCenterX = (prevEndRect.left - vpRect.left) + prevEndRect.width / 2;
                     const prevCenterY = (prevEndRect.top - vpRect.top) + prevEndRect.height / 2;
                     endRect.style.left = `${prevCenterX - newWidth / 2}px`;
                     endRect.style.top = `${prevCenterY - newHeight / 2}px`;
                 }

                console.log(`Resized rectangles to ${newWidth}x${newHeight}`);
                 // After resize, re-constrain rectangle positions just in case they went out of bounds
                 // Get viewport bounds *once* for constraining
                 const vpRect = viewport.getBoundingClientRect();
                 [startRect, endRect].forEach(rect => {
                     if (!rect) return;
                     let currentX = parseFloat(rect.style.left);
                     let currentY = parseFloat(rect.style.top);
                     currentX = Math.max(0, Math.min(currentX, vpRect.width - newWidth));
                     currentY = Math.max(0, Math.min(currentY, vpRect.height - newHeight));
                     rect.style.left = `${currentX}px`;
                     rect.style.top = `${currentY}px`;
                 });

            });

            // --- Start Transition Button Logic ---
            startButton.addEventListener('click', () => {
                // Use outer scope variables startRect and endRect
                if (!startRect || !endRect) return;

                // Assign name/ID on first run if needed
                if (!currentTransitionHasRun) {
                    if (currentTransitionName === "New Transition") {
                         currentTransitionId = Date.now();
                         currentTransitionName = `Transition ${new Date(currentTransitionId).toLocaleString()}`;
                    }
                     // If it has a custom name but no ID, assign ID now
                     else if (!currentTransitionId) {
                          currentTransitionId = Date.now();
                     }
                    currentTransitionHasRun = true;
                }

                // Change button text
                 startButton.textContent = 'Run Again';

                // Get Start/End Positions relative to viewport
                const startRectBounds = startRect.getBoundingClientRect();
                const endRectBounds = endRect.getBoundingClientRect();
                const vpRect = viewport.getBoundingClientRect();

                const startLeft = startRectBounds.left - vpRect.left;
                const startTop = startRectBounds.top - vpRect.top;
                const endLeft = endRectBounds.left - vpRect.left;
                const endTop = endRectBounds.top - vpRect.top;

                // Calculate Translation
                const translateX = endLeft - startLeft;
                const translateY = endTop - startTop;

                // Get Duration
                const duration = parseInt(durationInput.value, 10);
                const durationSeconds = duration / 1000;

                // --- Intermediate Points & Keyframes ---
                 const controlPoints = [
                    { x: startLeft, y: startTop }, // Start point
                    ...intermediatePoints.map(p => ({ x: p.x, y: p.y })), // Intermediate points (use raw coords)
                    { x: endLeft, y: endTop } // End point
                 ];

                 // Generate a smooth path through the points
                 const smoothPath = generateSplinePath(controlPoints);

                 if (smoothPath.length > 1) { // Only need keyframes for paths with > 1 segment
                     const keyframesName = `pathAnimation_${Date.now()}`;
                     let keyframesRule = `@keyframes ${keyframesName} {\n`;
                     const numPathPoints = smoothPath.length - 1;

                     // Generate keyframes based on the smooth path
                     smoothPath.forEach((point, index) => {
                         const percentage = (index / numPathPoints) * 100;
                         // Translate relative to the *initial* start position
                         const pointTranslateX = point.x - startLeft;
                         const pointTranslateY = point.y - startTop;
                         // Interpolate rotation based on overall percentage
                         const rotateXValue = xRotationDirection * 360 * (percentage / 100);
                         const rotateYValue = yRotationDirection * 360 * (percentage / 100);
                         const rotateZValue = zRotationDirection * 360 * (percentage / 100);

                         const transformValue = `translateX(${pointTranslateX}px) translateY(${pointTranslateY}px) rotateX(${rotateXValue}deg) rotateY(${rotateYValue}deg) rotateZ(${rotateZValue}deg)`;
                         keyframesRule += `  ${percentage}% { transform: ${transformValue}; }\n`;
                     });

                     keyframesRule += `}`;

                     // Inject keyframes into a style tag
                     const styleSheet = document.createElement("style");
                     styleSheet.type = "text/css";
                     styleSheet.innerText = keyframesRule;
                     document.head.appendChild(styleSheet);
                     console.log('Generated Keyframes:\n', keyframesRule);

                     // Apply animation
                     startRect.style.animation = `${keyframesName} ${durationSeconds}s ease-in-out forwards`; // Use forwards to keep end state

                     // Clean up style tag and animation property after completion
                     setTimeout(() => {
                        if (startRect) { // Check if element still exists
                             // Keep final position/transform by applying it directly before removing animation
                             const finalTransform = `translateX(${translateX}px) translateY(${translateY}px) rotateX(${xRotationDirection*360}deg) rotateY(${yRotationDirection*360}deg) rotateZ(${zRotationDirection*360}deg)`;
                             startRect.style.transform = finalTransform;
                             startRect.style.animation = 'none'; // Remove animation property
                             console.log('Animation finished, applied final transform');
                        }
                        styleSheet.remove();
                        console.log('Cleaned up keyframes style tag');
                    }, duration);

                 } else {
                     // Fallback to simple transition if no intermediate points
                     console.warn("Only start/end points defined, using simple transition.");
                     const transformValue = `translateX(${translateX}px) translateY(${translateY}px) rotateX(${xRotationDirection*360}deg) rotateY(${yRotationDirection*360}deg) rotateZ(${zRotationDirection*360}deg)`;
                     startRect.style.transition = `transform ${durationSeconds}s ease-in-out`;
                     startRect.style.transform = transformValue;
                     // Reset after transition
                     setTimeout(() => {
                         if (startRect) {
                              startRect.style.transition = 'none';
                              startRect.style.transform = `translateX(${translateX}px) translateY(${translateY}px)`; // Keep position, reset rotation
                              console.log('Simple transition ended, transform partially reset.');
                         }
                     }, duration);
                 }
            });

            // --- Replay Transition Button Logic ---
            replayButton.addEventListener('click', () => {
                 // Use outer scope variable startRect
                if (!startRect) return;

                // Instantly reset the green rectangle's transform and animation
                const currentLeft = startRect.style.left;
                const currentTop = startRect.style.top;
                startRect.style.transition = 'none';
                startRect.style.animation = 'none'; // Clear previous animation
                startRect.style.left = currentLeft;
                startRect.style.top = currentTop;
                startRect.style.transform = ''; // Reset transform completely

                // Delay slightly before starting the animation again
                 requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                         startButton.click(); // Trigger the full animation logic
                         console.log('Replaying transition (potentially with keyframes)...');
                    });
                });
            });

            // --- Rotation Direction Toggle Logic ---
            const directionToggles = document.querySelectorAll('.direction-toggle');
            directionToggles.forEach(toggle => {
                const axis = toggle.dataset.axis;
                const buttons = toggle.querySelectorAll('.btn-dir');
                buttons.forEach(button => {
                    button.addEventListener('click', () => {
                        const newDirection = parseInt(button.dataset.value, 10);
                        if (axis === 'x') xRotationDirection = newDirection;
                        else if (axis === 'y') yRotationDirection = newDirection;
                        else if (axis === 'z') zRotationDirection = newDirection;
                        console.log(`Set ${axis}-axis direction to: ${newDirection}`);
                        buttons.forEach(btn => btn.classList.remove('active'));
                        button.classList.add('active');
                    });
                });
            });

             // --- Point Management Logic ---
             // Uses viewport, addWaypointButton, removeWaypointButton from outer scope
            addWaypointButton.addEventListener('click', () => {
                isAddingPoints = !isAddingPoints;
                 if (isAddingPoints) {
                     addWaypointButton.textContent = 'Add+';
                     addWaypointButton.style.backgroundColor = '#28a745'; // Green
                     viewport.style.cursor = 'crosshair';
                     selectPoint(-1); // Deselect any selected point
                     console.log('Entered Add Waypoint mode.');
                 } else {
                     exitAddPointMode();
                 }
            });

            viewport.addEventListener('click', (e) => {
                if (!isAddingPoints || draggingPointIndex !== -1) return;
                // Only add if clicking directly on viewport
                if (e.target === viewport) {
                     const vpRect = viewport.getBoundingClientRect();
                     const x = e.clientX - vpRect.left;
                     const y = e.clientY - vpRect.top;
                     addIntermediatePoint(x, y);
                     // Stay in adding mode - DO NOT exit here
                }
            });

             // Exit Add Mode by clicking outside viewport or pressing Esc
             document.addEventListener('click', (e) => {
                 if (isAddingPoints && !viewport.contains(e.target) && e.target !== addWaypointButton) {
                     console.log('Clicked outside viewport.');
                     exitAddPointMode();
                 }
             });
             document.addEventListener('keydown', (e) => {
                 if (isAddingPoints && e.key === 'Escape') {
                     console.log('Escape pressed.');
                     exitAddPointMode();
                 }
             });

            function exitAddPointMode() {
                 if (!isAddingPoints) return;
                 isAddingPoints = false;
                 addWaypointButton.textContent = 'Add'; // Reset button text
                 // Optional: Reset button background
                 addWaypointButton.style.backgroundColor = '';
                 viewport.style.cursor = 'default';
                 console.log('Exited Add Waypoint mode.');
            }

            function addIntermediatePoint(x, y) {
                const marker = document.createElement('div');
                marker.className = 'point-marker';
                marker.style.left = `${x}px`;
                marker.style.top = `${y}px`;
                viewport.appendChild(marker);
                const pointData = { x, y, element: marker };
                const pointIndex = intermediatePoints.length;
                intermediatePoints.push(pointData);
                console.log('Added waypoint'); // Less verbose log
                updateWaypointCounter(); // Update counter

                marker.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent viewport click event
                    // Don't select points in add mode, maybe exit mode?
                    // For now, clicking a point while adding does nothing extra
                });

                 // Make the new point draggable
                 makePointDraggable(marker, pointIndex);

                 // Check limit BEFORE adding to DOM/array
                 if (intermediatePoints.length >= 99) {
                     console.warn('Maximum waypoint limit (99) reached.');
                     // Optionally exit add mode if limit is hit while adding
                     if (isAddingPoints) {
                         exitAddPointMode();
                     }
                     return; // Do not add the point
                 }
            }

            function selectPoint(index) {
                if (selectedPointIndex !== -1 && intermediatePoints[selectedPointIndex]) {
                    intermediatePoints[selectedPointIndex].element.classList.remove('selected');
                }
                if (selectedPointIndex === index) {
                    selectedPointIndex = -1;
                    console.log('Deselected point', index);
                    return; // Exit early
                } else {
                    selectedPointIndex = index;
                    if (intermediatePoints[index]) { // Check point exists
                         intermediatePoints[index].element.classList.add('selected');
                         console.log('Selected point', index);
                    } else {
                        console.error('Attempted to select non-existent point at index:', index);
                        selectedPointIndex = -1; // Reset selection
                    }
                }
            }

            // Renamed from removeWaypointButton listener logic
            function removePointByIndex(indexToRemove) {
                if (indexToRemove < 0 || indexToRemove >= intermediatePoints.length || !intermediatePoints[indexToRemove]) {
                    console.warn('Invalid index for removePointByIndex:', indexToRemove);
                    return;
                }
                console.log('Removing point', indexToRemove);
                intermediatePoints[indexToRemove].element.remove();
                intermediatePoints.splice(indexToRemove, 1);
                updateWaypointCounter(); // Update counter

                const oldSelectedIndex = selectedPointIndex;

                // Clear selection if the removed point was selected
                if (selectedPointIndex === indexToRemove) { // If deleting the selected point
                    selectedPointIndex = -1; // Clear selection
                } else if (selectedPointIndex > indexToRemove) { // If deleting a point before the selected one
                    // Adjust selected index if it came after the removed one
                    selectedPointIndex--;
                }

                // Adjust indices and reattach listeners for subsequent points
                intermediatePoints.forEach((p, i) => {
                     if (i >= indexToRemove) {
                          // Re-index listener immediately
                           // Re-add select listener
                           p.element.onclick = (e) => {
                               e.stopPropagation();
                               selectPoint(i);
                           };
                         // Re-apply selected style if needed
                         if (i === selectedPointIndex && p.element) {
                             p.element.classList.add('selected');
                         }
                     }
                });
            }

            // --- Dragging Logic (Points) ---
            function makePointDraggable(marker, index) {
                 let isDraggingPoint = false;

                 marker.addEventListener('mousedown', (e) => {
                     // Prevent viewport click & rect drag
                     e.stopPropagation();
                     // Don't drag if in add mode
                     if (isAddingPoints) return;

                     isDraggingPoint = true;
                     draggingPointIndex = index;
                     marker.style.cursor = 'grabbing';
                     marker.style.transition = 'none'; // Disable transition during drag
                     marker.style.zIndex = '10'; // Bring to front
                     document.body.style.cursor = 'grabbing'; // Optional: change body cursor

                     const rect = marker.getBoundingClientRect();
                     // Calculate offset from mouse click to marker top-left and store in outer scope
                     dragOffsetX = e.clientX - rect.left;
                     dragOffsetY = e.clientY - rect.top;

                     // Don't select just by starting drag, select happens on click
                 });

                 // Mousemove and Mouseup are handled globally now
            }

             // --- Global Mouse Move for Dragging Points ---
             document.addEventListener('mousemove', (e) => {
                 if (draggingPointIndex === -1) return; // Not dragging a point

                 const pointData = intermediatePoints[draggingPointIndex];
                 if (!pointData) return;

                 const marker = pointData.element;
                 const vpRect = viewport.getBoundingClientRect();

                 // Calculate new marker top-left position relative to viewport using outer scope offsets
                 let newX = e.clientX - vpRect.left - dragOffsetX;
                 let newY = e.clientY - vpRect.top - dragOffsetY;

                 // Update visual position
                 marker.style.left = `${newX}px`;
                 marker.style.top = `${newY}px`;
             });

             // --- Global Mouse Up for Dragging Points ---
             document.addEventListener('mouseup', (e) => {
                 if (draggingPointIndex === -1) return; // Not dragging a point

                 const pointData = intermediatePoints[draggingPointIndex];
                 const marker = pointData.element;
                 const vpRect = viewport.getBoundingClientRect();

                 marker.style.cursor = 'pointer';
                 marker.style.transition = '';
                 marker.style.zIndex = '3';
                 document.body.style.cursor = 'default';

                 // Get final position relative to viewport
                 const finalX = parseFloat(marker.style.left); // This is top-left
                 const finalY = parseFloat(marker.style.top);
                 const markerWidth = marker.offsetWidth;
                 const markerHeight = marker.offsetHeight;

                 // Check if center of marker is outside viewport bounds
                 const centerX = finalX + markerWidth / 2;
                 const centerY = finalY + markerHeight / 2;

                 const isOutside = (
                     centerX < 0 ||
                     centerX > vpRect.width ||
                     centerY < 0 ||
                     centerY > vpRect.height
                 );

                 if (isOutside) {
                     console.log(`Point ${draggingPointIndex} dragged outside - deleting.`);
                     removePointByIndex(draggingPointIndex);
                 } else {
                     // Update the data array with the new constrained position
                     pointData.x = finalX;
                     pointData.y = finalY;
                     console.log(`Point ${draggingPointIndex} moved to:`, pointData.x, pointData.y);
                      // Optionally re-select after move, or clear selection
                      selectPoint(-1); // Deselect after move
                 }

                 draggingPointIndex = -1; // Stop dragging
             });

            // --- Theming --- (Moved theme logic here)
            function applyTheme(theme) {
                if (theme === 'dark') {
                    document.body.classList.add('dark-theme');
                } else {
                    document.body.classList.remove('dark-theme');
                }
                localStorage.setItem('transformTesterTheme', theme);
            }

            themeToggleButton.addEventListener('click', () => {
                const currentTheme = document.body.classList.contains('dark-theme') ? 'dark' : 'light';
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                applyTheme(newTheme);
            });

            // Load saved theme on startup
            const savedTheme = localStorage.getItem('transformTesterTheme') || 'light';
            applyTheme(savedTheme);

            // --- Save Button Logic (for Current Configuration) ---
            saveButton.addEventListener('click', () => {
                if (!startRect || !endRect) {
                    alert('Cannot save, rectangles not initialized.');
                    return;
                }

                 // Assign name/ID if it's still "New Transition" and hasn't run
                 if (currentTransitionName === "New Transition" && !currentTransitionHasRun) {
                     currentTransitionId = Date.now();
                     currentTransitionName = `Transition ${new Date(currentTransitionId).toLocaleString()}`;
                     console.log('Assigning default name/ID before saving:', currentTransitionName, currentTransitionId);
                 } else if (!currentTransitionId) {
                     // Has a custom name but no ID yet (wasn't run/loaded)
                     currentTransitionId = Date.now();
                     console.log('Assigning new ID before saving custom name:', currentTransitionId);
                 }

                const transitionToSave = {
                    id: currentTransitionId,
                    name: currentTransitionName,
                    duration: parseInt(durationInput.value, 10),
                    rectWidth: parseInt(widthInput.value, 10),
                    rectHeight: parseInt(heightInput.value, 10),
                    startX: startRect.style.left,
                    startY: startRect.style.top,
                    endX: endRect.style.left,
                    endY: endRect.style.top,
                    points: intermediatePoints.map(p => ({ x: p.x, y: p.y })), // Save only coords
                    rotX: xRotationDirection,
                    rotY: yRotationDirection,
                    rotZ: zRotationDirection
                };

                let transitions = getSavedTransitions();
                const existingIndex = transitions.findIndex(t => t.id === transitionToSave.id);

                if (existingIndex !== -1) {
                    // Update existing transition
                    transitions[existingIndex] = transitionToSave;
                    console.log('Updated existing transition in localStorage:', transitionToSave);
                } else {
                    // Add as new transition
                    transitions.push(transitionToSave);
                    console.log('Saved new transition:', transitionToSave);
                }
                saveTransitions(transitions);

                renderSavedList(); // Refresh the list
                 // Provide visual feedback via the button itself (optional)
                 saveButton.textContent = 'Saved!';
                 saveButton.style.backgroundColor = '#28a745'; // Green flash
                 setTimeout(() => {
                     saveButton.textContent = 'Save Current Configuration';
                     saveButton.style.backgroundColor = ''; // Reset color
                 }, 1000);
            });

            // --- Rename Saved Transition ---
            renameButton.addEventListener('click', () => {
                if (!selectedSavedTransitionId) return;
                const newName = renameInput.value.trim();
                if (!newName) {
                    alert('Please enter a valid name.');
                    return;
                }

                let transitions = getSavedTransitions();
                const index = transitions.findIndex(t => t.id === selectedSavedTransitionId);
                if (index !== -1) {
                    transitions[index].name = newName;
                    saveTransitions(transitions);
                    console.log('Renamed transition', selectedSavedTransitionId, 'to', newName);
                    renderSavedList(); // Re-render to show new name and clear selection
                } else {
                    console.error('Could not find transition to rename:', selectedSavedTransitionId);
                }
            });

            // --- Delete Saved Transition ---
            deleteButton.addEventListener('click', () => {
                if (!selectedSavedTransitionId) return;
                if (!confirm('Are you sure you want to delete this saved transition?')) {
                    return;
                }

                let transitions = getSavedTransitions();
                transitions = transitions.filter(t => t.id !== selectedSavedTransitionId);
                saveTransitions(transitions);
                console.log('Deleted transition', selectedSavedTransitionId);
                renderSavedList(); // Re-render list and clear selection
            });

            // --- Replay Saved Transition ---
            replaySavedButton.addEventListener('click', () => {
                if (!selectedSavedTransitionId) return;

                const transitions = getSavedTransitions();
                const savedState = transitions.find(t => t.id === selectedSavedTransitionId);
                if (!savedState) {
                    alert('Error: Could not find saved transition data.');
                    return;
                }

                console.log('Loading and replaying saved state:', savedState.id);

                // 0. Update Current Transition State
                currentTransitionName = savedState.name;
                currentTransitionId = savedState.id;
                currentTransitionHasRun = true; // Mark as run since it's loaded

                // 1. Restore State
                // Clear current intermediate points visually and from array
                 intermediatePoints.forEach(p => p.element.remove());
                 intermediatePoints = [];
                 selectedPointIndex = -1;

                 // Set Rect sizes
                 widthInput.value = savedState.rectWidth;
                 heightInput.value = savedState.rectHeight;
                 applySizeButton.click(); // Trigger resize logic (includes recentering)

                 // Set Rect positions (ensure they exist first)
                 if (startRect) {
                     startRect.style.left = savedState.startX;
                     startRect.style.top = savedState.startY;
                     startRect.style.transform = ''; // Reset transform before replay
                     startRect.style.animation = 'none'; // Reset animation
                 }
                 if (endRect) {
                     endRect.style.left = savedState.endX;
                     endRect.style.top = savedState.endY;
                 }

                 // Recreate intermediate points
                 savedState.points.forEach(p => addIntermediatePoint(p.x, p.y));

                 // Set duration
                 durationInput.value = savedState.duration;

                 // Set rotation directions (update state vars and button UI)
                 xRotationDirection = savedState.rotX;
                 yRotationDirection = savedState.rotY;
                 zRotationDirection = savedState.rotZ;
                 document.querySelectorAll('.direction-toggle').forEach(toggle => {
                     const axis = toggle.dataset.axis;
                     let currentDir;
                     if (axis === 'x') currentDir = xRotationDirection;
                     else if (axis === 'y') currentDir = yRotationDirection;
                     else if (axis === 'z') currentDir = zRotationDirection;
                     toggle.querySelectorAll('.btn-dir').forEach(btn => {
                         btn.classList.toggle('active', parseInt(btn.dataset.value) === currentDir);
                     });
                 });

                // 2. Trigger Replay
                // Use a slight delay to ensure DOM updates from state restoration are processed
                setTimeout(() => {
                    replayButton.click(); // Click the main replay button
                }, 50); // 50ms delay

                // Update the name displayed in the saved list if it was selected
                const listItem = savedListUl.querySelector(`li[data-id="${savedState.id}"]`);
                if (listItem && listItem.classList.contains('selected')) {
                   const nameSpan = listItem.querySelector('.transition-name');
                   if (nameSpan) nameSpan.textContent = currentTransitionName;
                }

                startButton.textContent = 'Run Loaded'; // Update main button text
            });

            // --- Waypoint Counter Update ---
            function updateWaypointCounter() {
                const count = intermediatePoints.length;
                waypointCounter.textContent = count;
                deleteLastWaypointButton.disabled = count === 0;
                addWaypointButton.disabled = count >= 99;
            }

            // --- Initial Call ---
            initializeRects();
            renderSavedList(); // Load and display saved list on startup
            updateWaypointCounter(); // Set initial counter and button state
        });
    </script>

</body>
</html> 